# Specifications

## Overview

A local web application for learning a foreign language (initially Slovenian) aimed at an American English speaker. The app teaches vocabulary and grammar *in context* by presenting glossed sentences and lemma (word) pages. Content is generated by an LLM on demand and cached in a local SQLite database.

---

## Goals and Non-goals

### Goals

- Teach foreign-language vocabulary and grammar in context to an American English speaker.
- Focus on reading comprehension (listening is a future goal).
- Generate content on demand to minimize LLM costs; cache all generated content.

### Non-goals

- Writing or speaking practice.
- Spaced repetition or progress tracking.

---

## Technology Stack

| Component        | Technology                          |
|------------------|-------------------------------------|
| Back-end         | Flask (Python)                      |
| Front-end        | HTML, Tailwind CSS, HTMX            |
| Database         | SQLite                              |
| Program / deps   | `uv` (`pyproject.toml`)             |
| Forms / CSRF     | Flask-WTF (CSRFProtect)             |
| RSS fetching     | `requests` + `feedparser`           |
| Content generation | LLM (OpenAI; default model `gpt-5-nano`) |
| CSS build        | Tailwind CSS standalone CLI         |

---

## Terminology

### Language

A target foreign language, identified by a two-letter code in URLs and the database (e.g., `sl` for Slovenian, `de` for German).

### Sentence

A single normalized sentence of foreign-language text.

- **Normalization**: Unicode NFKC with internal whitespace collapsed (no double spaces) and leading/trailing whitespace trimmed.
- **Invariant**: All sentences are normalized before being inserted into the database, so all stored sentence text is already normalized.
- **Sources**: (The first sentences of) RSS headlines from configured feeds.
- **Hash slug**: The first 16 hex characters of the SHA-256 hash of the normalized text, lowercased.
- **URL pattern**: `/<lang>/sentence/<hash_slug>` (e.g., `/sl/sentence/a1b2c3d4e5f6g7h8`).


### Token

A clickable unit within a displayed sentence.

- **Tokenization**:
  - Tokenization is produced by the LLM as part of sentence page generation, not by a local rule-based tokenizer (e.g., NLTK or spaCy).
  - The LLM must return tokens in reading order such that concatenating token surfaces (inserting appropriate whitespace between tokens) reconstructs the original sentence text.
  - The LLM must return multi-word proper nouns as a single token spanning internal whitespace (e.g., `New York`).
  - The LLM must return punctuation as separate tokens.
- **Surface vs normalized form**:
  - Display uses the original surface string as returned by the LLM.
  - Database lookups assume stored sentence text and lemma identifiers are already normalized.
- **Punctuation tokens**: Displayed but not clickable; have no associated lemma.
- **Loanword tokens**: Foreign loanwords (e.g., English words in Slovenian headlines) are displayed but not lemmatized. The LLM marks these with `is_loanword: true`; they appear with empty gloss area below.


### Lemma

The canonical dictionary form of a token.

- **Normalization**: Unicode NFKC with internal whitespace collapsed (no double spaces) and leading/trailing whitespace trimmed.
- **Invariant**: All lemma identifier strings stored in the database are already normalized.
- **URL input**: Lemma path segments are user-provided; the server must normalize the URL-decoded lemma string before database lookup.

| Part of speech           | Lemma form                                      |
|--------------------------|-------------------------------------------------|
| Common noun              | Nominative singular, lowercase                  |
| Adjective                | Masculine nominative singular, lowercase        |
| Verb                     | Infinitive, lowercase                           |
| Adverb, preposition, conjunction, etc. | Lowercase                        |
| Proper noun              | Full string with original capitalization        |
| Punctuation              | No lemma (not stored)                           |

- **Identity**: A lemma is uniquely identified in the database by `(language, normalized_lemma_string)`.
- **URL pattern**: `/<lang>/lemma/<normalized_lemma>` (URL-encoded)
- **Lookup**: The server URL-decodes and normalizes the lemma segment before looking up `lemmas.normalized_lemma`.

---

## User Model

### Overview

- Login (username + password) is required for access.
- The app does **not** track individual user progress; cached content and access counts are shared globally across all users.
- Multiple user accounts may exist, but they share a single content database.
- Each user has a `default_language` preference, which affects the sentence page displayed after login or upon accessing the path `/`.
- Each user has their own favorites list (sentences and lemmas). Favorites are per-user, not shared globally.

### Credential Management

- User records are stored in the SQLite database (`users` table).
- Users are created, updated, or deleted via a command-line admin script (not via the web UI).
- There is no self-service registration or password reset.

### Password Storage

- Passwords are hashed with a salted algorithm (e.g., PBKDF2-SHA256 via Werkzeug).
- The `users` table stores: `username`, `password_hash`, `default_language`.

### Session Policy

- Flask session cookies maintain login state.
- Sessions are persistent ("remember me") and do not expire until the browser clears cookies or the server secret key changes.
- Cookies are `HttpOnly`, `Secure` when served over HTTPS (disabled for local HTTP), and scoped as a host-only cookie.
- Every request (except `/login`) requires a valid session; unauthenticated requests redirect to `/login`.
- CSRF protection is enabled for login and all state-changing actions.
- No explicit logout functionality. Sessions only end when the browser clears cookies or the server secret key changes.

### Login Rate Limiting

- Per-username exponential backoff on failed login attempts.
- **Storage**: In-memory (resets on server restart).
- Initial delay: 5 seconds after first failure.
- Multiplier: 2x on each subsequent failure.
- Maximum delay: 60 seconds.
- Reset: Delay counter resets to zero on successful login.
- Decay: Delay counter decays to zero after 1 hour of no login attempts for that username.

---

## Pages

### Login Page

- **URL**: `/login`
- Displays a username/password form.
- On success, redirects to `/<default_language>/` (the user's default language sentence list).
- On failure, redisplays with an error message.

### Sentence List Page

- **URL**: `/<lang>/` (e.g., `/sl/`)
- Returns 404 if the language code has no configured feeds in `feeds.yaml`.
- Lists sentences in the database for the given language.
- Includes an "Update" button above the list that fetches new RSS headlines for the current language from enabled feeds and inserts any new sentences.
  - Update is a state-changing action and must be CSRF-protected.
  - Update does not push a new browser history entry and does not change the URL.
  - If some feeds fail, continue with others; the list refreshes without explicit feedback.
- Each row shows:
  - The full sentence text (no truncation).
  - A filled star icon if the sentence is in the user's favorites.
  - Parenthesized access count (omit if access count is zero; never-accessed sentences show no count).
- Sorted by insert time, newest first.
- No pagination or search/filter. All sentences displayed.
- Clicking a sentence navigates to its detail page. Words/lemmas are not separately clickable.

### Sentence Detail Page

- **URL**: `/<lang>/sentence/<hash_slug>`
- If the hash does not exist in the database, redirect to the sentence list page for that language.
- **Layout** (top to bottom):

  1. **Glossed sentence** (bold):
     - Each token displayed as an inline-block with its gloss directly below (interlinear style).
     - Token blocks are separated by horizontal spacing only (no borders or backgrounds).
     - Sentence wraps naturally to multiple lines if long.
     - Gloss text is the same size as the token but uses muted color/lighter weight.
     - Gloss format: `translation.tag1.tag2` (Leipzig abbreviations, dot-separated, tags after translation, e.g., `to run.3.sg`).
     - If a word has no Leipzig tags (e.g., simple prepositions), show translation only without POS annotation.
     - Allowable Leipzig Glossing tags: `1`, `2`, `3`, `sg`, `du`, `pl`, `nom`, `gen`, `dat`, `acc`, `ins`, `loc`, `refl`, `m`, `f`, `n`.
     - Word tokens link to their lemma page; show underline on hover (standard link behavior).
     - Punctuation tokens have the same inline-block layout but with empty gloss row.
     - Loanword tokens (foreign words not lemmatized) display with empty gloss area below.

  2. **Proper noun definitions** (optional):
     - A list of proper nouns in the sentence unfamiliar to most Americans.
         - Exclude globally famous proper nouns like `Paris` or `Mozart`
         - Include all local figures, places, or organizations
         - Include famous places if their English name is different, e.g., `Vienna` is famous, but its Slovenian name `Dunaj` should be explained.
         - Detect proper nouns in any grammatical case form; show nominative form in the definition.
     - Each entry: proper noun (nominative case) + brief definition/explanation.
     - Plain text display with simple heading (no boxes or backgrounds).
     - Per-sentence (not cached/shared across sentences).
     - Omitted if the sentence contains no unfamiliar proper nouns.

  3. **Grammar notes** (optional):
     - Surprising grammar features for an English speaker.
     - Excludes basics that apply to most languages (e.g., adjective gender agreement, verb number agreement).
     - Focuses on tense/mood/aspect differences, unusual word order, constructions without direct English equivalents.
     - Direct explanations without English comparisons (not "Unlike English...").
     - Plain text display with simple heading (no boxes or backgrounds).
     - Omitted if the sentence contains only straightforward grammar.

  4. **Action controls** (grouped together):
     - **Favorite toggle**: Clickable star icon that fills when favorited. HTMX in-place update (no history push).
     - **Regenerate controls**:
       - A dropdown to select an LLM model (shows all three: nano/mini/gpt-5). Session remembers last selected model.
       - A button labeled "Regenerate" (disabled with text "Regenerating..." during LLM call).
       - A label showing which model generated the current content.
       - Clicking "Regenerate" re-generates all content for the page, replaces the cached data, and reloads. No history is kept. No cooldown.
     - **Delete button**: Immediately deletes the sentence (no confirmation dialog), keeps article in `rss_articles` (won't re-import), redirects to sentence list.

- **LLM failure**: If generation fails after retries, show error message with "Try again" button and model selector. Sentence text remains visible.
- **Access counting**: Each full page load (not HTMX partial) increments the sentence's access count by 1.
- **Ambiguity handling**: LLM picks the single most contextually appropriate lemma when a word could have multiple analyses.

### Lemma Detail Page

- **URL**: `/<lang>/lemma/<normalized_lemma>` (URL-encoded)
- **Lookup**: The server URL-decodes and normalizes the lemma segment before looking up `lemmas.normalized_lemma`.
- **Lemma creation**: Lemma records are created only when the page is first accessed (not eagerly when referenced).
- **Content generation**: If the lemma has no cached content, generate inline with loading state, then display.
- **Layout** (top to bottom):

  1. **Lemma and translation**:
     - The lemma (bold).
     - English translation listing 2-3 common meanings if the word is polysemous.

  2. **Related words** (optional, max 8):
     - A list of any linguistically relevant related words/phrases with translations (not restricted to words in the database).
     - Each entry includes a short note explaining why it is related (e.g., etymological relation, false friend, near-synonym distinction).
     - Entries may not always be lemmas in the dictionary sense; each entry includes a `normalized_lemma` link target and links to that lemma page.
     - Related word links use subtle styling (match surrounding text, subtle underline on hover).
     - Clicking a related word navigates to its lemma page (full navigation, pushes history).
     - Excludes inflected/conjugated forms of the same lemma.
     - May be shorter or omitted if no good candidates.

  3. **Action controls** (grouped together):
     - **Favorite toggle**: Clickable star icon that fills when favorited. HTMX in-place update (no history push).
     - **Regenerate controls**: Same as sentence detail page.

- **Access counting**: Each full page load increments the lemma's access count by 1.

### Root Page

- **URL**: `/`
- Redirects to `/login` if not logged in.
- Otherwise redirects to `/<default_language>/` (the user's default language).

### Favorites Page

- **URL**: `/favorites`
- Accessible via header navigation link.
- Displays a unified list of the user's favorited items across all languages.
- **Layout**:
  - **Sentences section**: List of favorited sentences, sorted by when favorited (newest first).
  - **Lemmas section**: List of favorited lemmas, sorted by when favorited (newest first).
- Clicking an item navigates to its detail page (full navigation).

---

## UI & Styling

### Branding

- **App name**: "Second Language" (displayed in header and page titles).
- **Favicon**: Include a simple favicon.
- **Logo**: Simple logo/app name in header.
- **Footer**: Display app version (read from `pyproject.toml`).

### CSS Framework

- Tailwind CSS using the standalone CLI (not npm).
- Single light theme only (no dark mode).

### Loading States

- Use native browser loading indicators only.
- No custom spinners or progress bars during navigation.
- Regenerate button shows "Regenerating..." text while disabled during LLM calls.

### Navigation Header

- Show language switcher only if multiple languages are configured in `feeds.yaml`.
- Show favorites link.
- No username display (app feels single-user).

---

## Data Storage (SQLite)

### Purpose

- Cache all LLM-generated content so pages render instantly on repeat visits.
- Track access counts for sentences and lemmas.
- Track processed RSS articles to avoid duplicates.
- Store user credentials.
- Store per-user favorites.

### Tables (conceptual)

| Table           | Key columns                                                                 |
|-----------------|-----------------------------------------------------------------------------|
| `users`         | `username`, `password_hash`, `default_language`                             |
| `sentences`     | `id`, `language`, `hash`, `text`, `gloss_json`, `proper_nouns_json`, `grammar_notes_json`, `model_used`, `schema_version`, `access_count`, `created_at`, `updated_at` |
| `lemmas`        | `id`, `language`, `normalized_lemma`, `translation`, `related_words_json`, `model_used`, `schema_version`, `access_count`, `created_at`, `updated_at` |
| `rss_articles`  | `feed_id`, `article_id`                                    |
| `favorites`     | `id`, `username`, `item_type`, `item_id`, `created_at`                      |

### Schema (DDL)

All cached payload fields are stored as JSON in `TEXT` columns.

The database stores a versioning field to control cache invalidation:

- `schema_version` (integer column): bumped when the JSON structure changes. Stored only in the database column, not duplicated inside JSON payloads.

Cached content with mismatched `schema_version` is treated as a cache miss and regenerated on next access.

```sql
CREATE TABLE IF NOT EXISTS users (
  username TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  default_language TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS sentences (
  id INTEGER PRIMARY KEY,
  language TEXT NOT NULL,
  hash TEXT NOT NULL,
  text TEXT NOT NULL,
  gloss_json TEXT,
  proper_nouns_json TEXT,
  grammar_notes_json TEXT,
  model_used TEXT,
  schema_version INTEGER NOT NULL,
  access_count INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  UNIQUE(language, hash)
);

CREATE INDEX IF NOT EXISTS idx_sentences_language_created_at
  ON sentences(language, created_at DESC);

CREATE TABLE IF NOT EXISTS lemmas (
  id INTEGER PRIMARY KEY,
  language TEXT NOT NULL,
  normalized_lemma TEXT NOT NULL,
  translation TEXT,
  related_words_json TEXT,
  model_used TEXT,
  schema_version INTEGER NOT NULL,
  access_count INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  UNIQUE(language, normalized_lemma)
);

CREATE INDEX IF NOT EXISTS idx_lemmas_language_created_at
  ON lemmas(language, created_at DESC);

CREATE TABLE IF NOT EXISTS rss_articles (
  feed_id TEXT NOT NULL,
  article_id TEXT NOT NULL,
  PRIMARY KEY(feed_id, article_id)
);

CREATE TABLE IF NOT EXISTS favorites (
  id INTEGER PRIMARY KEY,
  username TEXT NOT NULL,
  item_type TEXT NOT NULL CHECK(item_type IN ('sentence', 'lemma')),
  item_id INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  UNIQUE(username, item_type, item_id),
  FOREIGN KEY (username) REFERENCES users(username) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_favorites_username
  ON favorites(username, created_at DESC);
```

Foreign keys are not required for token-to-lemma relationships because tokenization and lemma links are stored inside cached JSON payloads.

**Cascade delete behavior**:
- When a user is deleted, their favorites are automatically deleted (ON DELETE CASCADE).
- When a sentence or lemma is deleted, the application must first delete any favorites pointing to it (DELETE FROM favorites WHERE item_type=? AND item_id=?).

---

## RSS Ingestion

### Behavior

- RSS headlines are fetched only when the user clicks the "Update" button on the sentence list page for a language.
- The update operation fetches headlines from configured, enabled feeds for that language.
- RSS fetching uses `requests` for HTTP and `feedparser` for parsing.
- If some feeds fail during update, continue with remaining feeds (partial failure handling).
- For each new article (not previously seen):
  1. Extract headline text.
  2. Treat the headline text as one logical sentence.
  3. Process the headline: decode HTML entities (`&amp;`, `&quot;`, etc.), strip editorial markers (`[VIDEO]`, `[FOTO]`, etc.) and truncation markers (`...`).
  4. Normalize the sentence (Unicode NFKC, collapse whitespace, trim).
  5. Skip headlines that become empty after processing.
  6. Call LLM to generate content (gloss, proper nouns, grammar notes).
  7. Only insert the sentence into the `sentences` table if LLM generation succeeds.
  8. If LLM fails, skip that headline (do not add to database or deduplication table).

**Note**: Content is generated eagerly at import time, not lazily on first access. This ensures all sentences in the database have complete content.

### Feed Configuration

- Feeds are defined in a configuration file `feeds.yaml`.
- **Startup validation**: Exit with clear error if `feeds.yaml` is missing or contains malformed YAML.
- Each feed specifies: URL, language code, enabled/disabled flag.
- Feed management is via manual YAML editing only (no CLI commands for feeds).
- **Language validity**: A language is valid if ANY feed entry exists for that language code, regardless of whether feeds are enabled or disabled.
- Articles are deduplicated by the RSS item's `id`/GUID field as returned by the RSS parser.
  - If the feed does not provide an `id`/GUID, fall back to a hash of the item's link URL.
- Deleting a sentence keeps its article_id in `rss_articles` (sentence won't be re-imported).

---

## LLM Integration

### Supported Models

- OpenAI models: `gpt-5-nano` (default), `gpt-5-mini`, and `gpt-5`.
- Model selector always shows all three models (API will reject if not accessible).

### Configuration

- API keys provided via environment variables: `OPENAI_API_KEY`.
- Model selection stored per cached page (so regeneration can use a different model).
- Session remembers last selected model for convenience.

### Startup Validation

- On app startup, call the OpenAI `/models` endpoint (free, no cost) to verify the API key is valid.
- If the test call fails, exit with a clear error message (app won't function without valid key).

### Request Handling

- Timeout: 60 seconds.
- Retries: up to 2 retries on transient errors (429, 500, 502, 503, 504).
- Malformed output: if LLM returns invalid JSON, attempt one retry; if still invalid, display an error and do not cache.

### Failure Display

- On LLM failure after retries, show error message with "Try again" button alongside model selector.
- Original content (sentence text, lemma) remains visible during error state.

### Cost Controls

- No cost control.
- No rate limiting or cooldown on regeneration for authenticated users.

---

## Navigation and Browser History

- All page navigations (sentence list → sentence detail → lemma detail → related lemma) must push to browser history.
- The browser back button must return to the previous page correctly.
- HTMX is used for interactivity; use `hx-push-url="true"` or full-page navigations to ensure history works.

### HTMX partial updates (no history push)

The following actions use HTMX partial updates that do not push browser history:
- Regeneration (replaces page content in place, does not increment access count).
- Favorite toggle (updates star icon in place).
- RSS Update button on sentence list (refreshes list content).

---

## Deployment

### Local Deployment

- The app is designed for local/single-machine deployment.
- Run via Flask development server or a production WSGI server (e.g., gunicorn).

### Environment Variables

| Variable            | Purpose                                      | Required |
|---------------------|----------------------------------------------|----------|
| `SECRET_KEY`        | Flask session signing key                    | Yes      |
| `DATABASE_PATH`     | Path to SQLite database file                 | Yes (no default) |
| `OPENAI_API_KEY`    | OpenAI API key                               | Yes      |

All environment variables are required. The app will fail to start if `DATABASE_PATH` is not set.

### Setup Steps

1. Create/initialize the SQLite database via `init_db.py`.
2. Create at least one user via the admin CLI.
3. Configure `feeds.yaml` with at least one RSS feed.
4. Set environment variables.
5. Start the Flask server (startup validates OpenAI API key).

---

## Implementation prerequisites (required to generate the implementation)

The following decisions define the contracts required to generate a correct and complete implementation:

### LLM output contracts (JSON schemas)

All cached LLM outputs must validate against the relevant schema version before being cached.

#### Sentence-detail generation (`schema_version = 1`)

Top-level object:

- `sentence_text` (string): must equal the normalized sentence text stored in `sentences.text`.
  - This intentionally duplicates the stored sentence string so cached payloads are self-contained and so the server can validate that the LLM output corresponds to the requested sentence.
- `tokens` (array of `Token`)
- `proper_nouns` (array of `ProperNoun`)
- `grammar_notes` (array of `GrammarNote`)
- `model_used` (string)

Note: `schema_version` is stored in the database column only, not in the JSON payload.

`Token` object:

- `leading` (string): either `""` or `" "` (or other whitespace) so that concatenating `leading + surface` for all tokens reconstructs `sentence_text`
- `surface` (string)
- `is_punct` (boolean)
- `is_loanword` (boolean, optional): true for foreign loanwords that should not be lemmatized
- If `is_punct` is `false` and `is_loanword` is not `true`:
  - `lemma` (string)
  - `pos` (string)
  - `gloss` (string)
  - `tags` (array of strings): subset of allowable Leipzig tags

`ProperNoun` object:

- `nominative` (string)
- `definition` (string)

`GrammarNote` object:

- `title` (string)
- `note` (string)

JSON Schema:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "SentenceDetailGenerationV1",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "sentence_text",
    "tokens",
    "proper_nouns",
    "grammar_notes",
    "model_used"
  ],
  "properties": {
    "sentence_text": {
      "type": "string",
      "minLength": 1,
      "description": "Must equal the normalized sentence text stored in sentences.text"
    },
    "tokens": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["leading", "surface", "is_punct"],
        "properties": {
          "leading": {
            "type": "string",
            "description": "Whitespace to place before surface; concatenating leading+surface for all tokens reconstructs sentence_text"
          },
          "surface": {
            "type": "string",
            "minLength": 1
          },
          "is_punct": {
            "type": "boolean"
          },
          "is_loanword": {
            "type": "boolean",
            "description": "True for foreign loanwords that should not be lemmatized"
          },
          "lemma": {
            "type": "string",
            "minLength": 1
          },
          "pos": {
            "type": "string",
            "minLength": 1
          },
          "gloss": {
            "type": "string",
            "minLength": 1
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "1",
                "2",
                "3",
                "sg",
                "du",
                "pl",
                "nom",
                "gen",
                "dat",
                "acc",
                "ins",
                "loc",
                "refl",
                "m",
                "f",
                "n"
              ]
            }
          }
        },
        "if": {
          "allOf": [
            { "properties": { "is_punct": { "const": false } } },
            { "not": { "properties": { "is_loanword": { "const": true } } } }
          ]
        },
        "then": {
          "required": ["lemma", "pos", "gloss", "tags"]
        }
      }
    },
    "proper_nouns": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["nominative", "definition"],
        "properties": {
          "nominative": { "type": "string", "minLength": 1 },
          "definition": { "type": "string", "minLength": 1 }
        }
      }
    },
    "grammar_notes": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["title", "note"],
        "properties": {
          "title": { "type": "string", "minLength": 1 },
          "note": { "type": "string", "minLength": 1 }
        }
      }
    },
    "model_used": {
      "type": "string",
      "minLength": 1
    }
  }
}
```

#### Lemma-page generation (`schema_version = 1`)

Top-level object:

- `lemma` (string)
- `normalized_lemma` (string): already normalized; used for storage and URLs
- `translation` (string)
- `related_words` (array of `RelatedWord`, length <= 8)
- `model_used` (string)

Note: `schema_version` is stored in the database column only, not in the JSON payload.

`RelatedWord` object:

- `word` (string)
- `normalized_lemma` (string): link target for a lemma page; may differ from `word`
- `translation` (string)
- `note` (string): explains why the related entry is included

JSON Schema:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "LemmaPageGenerationV1",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "lemma",
    "normalized_lemma",
    "translation",
    "related_words",
    "model_used"
  ],
  "properties": {
    "lemma": {
      "type": "string",
      "minLength": 1
    },
    "normalized_lemma": {
      "type": "string",
      "minLength": 1,
      "description": "Already normalized; used for storage and URLs"
    },
    "translation": {
      "type": "string",
      "minLength": 1
    },
    "related_words": {
      "type": "array",
      "maxItems": 8,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["word", "normalized_lemma", "translation", "note"],
        "properties": {
          "word": { "type": "string", "minLength": 1 },
          "normalized_lemma": { "type": "string", "minLength": 1 },
          "translation": { "type": "string", "minLength": 1 },
          "note": { "type": "string", "minLength": 1 }
        }
      }
    },
    "model_used": {
      "type": "string",
      "minLength": 1
    }
  }
}
```

#### Invalid JSON behavior

- On JSON parse or validation failure: attempt one retry.
- If still invalid: show a user-visible error and do not cache.

### SQLite schema DDL

The SQLite schema is defined in the Data Storage section.

### Admin CLI

A unified CLI script named `cli` manages users and sentences:

**User management:**
- `cli users list`
- `cli users create --username <username> --password <password> --default-language <lang>`
- `cli users update --username <username> [--password <password>] [--default-language <lang>]`
- `cli users delete --username <username>`

**Sentence management:**
- `cli sentences add --text <text> --language <lang>` (both arguments required)

**Validation:**
- `default_language`: lowercase two-letter language code matching `^[a-z]{2}$` with any feed entry (enabled or disabled) for that language in `feeds.yaml`.
- `--language` for sentences: must have any feed entry (enabled or disabled) for that language.

### `feeds.yaml` format

`./feeds.yaml` contains a list of feed objects. 
Feed object format:
- `id` (string, required)
- `url` (string, required)
- `language` (string, required; two-letter code)
- `enabled` (boolean, optional; default true)

Multiple feeds with the same language are allowed.

### No sentence splitting

RSS headlines are treated as one logical sentence, even if there are multiple grammatical sentences.

### HTMX navigation behavior

- Normal navigations push browser history.
- `Regenerate` is an HTMX partial update that replaces page content in place.
- Regeneration does not push a new history entry and does not change the URL.

### Security defaults

- CSRF protection uses Flask-WTF `CSRFProtect`.
- All HTML form submissions that change state must include a CSRF token.
- All HTMX requests that change state must include a CSRF token (e.g., via an `X-CSRFToken` header).
- Session cookies are `HttpOnly` and `SameSite=Lax`.
- `Secure` is enabled when served over HTTPS and disabled for local HTTP.
